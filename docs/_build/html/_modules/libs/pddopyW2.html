<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>libs.pddopyW2 &mdash; pyVerse2 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            pyVerse2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">modules package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../libs.html">libs package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyVerse2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">libs.pddopyW2</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for libs.pddopyW2</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">factorial</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="c1"># from pypardiso import spsolve</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">spsolve</span> <span class="c1">#Change this back to pypardiso! Using scipy only for MacOD</span>
<span class="kn">from</span> <span class="nn">scipy.sparse.linalg</span> <span class="kn">import</span> <span class="n">cg</span>

<div class="viewcode-block" id="find_neighbors">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.find_neighbors">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">find_neighbors</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neigbors of point i that are in range of delta. The funtions works on multidimensional points.</span>
<span class="sd">    Inputs:</span>
<span class="sd">    -----------</span>
<span class="sd">    coords : array of array of floats (coordinates of points=. shape = [number of points, dimensionality of points]. Coordinates should be floats.</span>
<span class="sd">    r      : radius of includivity. Points j that are distanced r or less, from point i, are considered to be members of point i. Should be float</span>

<span class="sd">    Outputs:</span>
<span class="sd">    -----------</span>
<span class="sd">    neighbors   : 1D array of floats (ID numbers of points). Contains the ID&#39;s of the neighbors of all points starting with the ID&#39;s of neighbors of point 0.</span>
<span class="sd">    start_index : 1D array of ints. Component &quot;i&quot; of the start_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; start.</span>
<span class="sd">    end_index   : 1D array of ints. Component &quot;i&quot; of the end_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; end.</span>
<span class="sd">    n_neighbors : 1D array of ints. Component &quot;i&quot; contains the number of neighbors that the point with ID = &quot;i&quot; has.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_neighbors</span> <span class="o">=</span> <span class="mi">120</span> <span class="c1"># This should change based on the dimensionality of the points. 28 is just for 2d and delta = 3 * dx.</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="o">*</span><span class="n">max_neighbors</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">current_neighbor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">dist</span> <span class="o">+=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">neighbors</span><span class="p">[</span><span class="n">current_neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="n">n_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">current_neighbor</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">start_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">end_index</span><span class="p">[:</span><span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">neighbors</span><span class="p">[:</span><span class="n">end_index</span><span class="p">[</span><span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">start_index</span><span class="p">,</span><span class="n">end_index</span><span class="p">,</span> <span class="n">n_neighbors</span></div>


<div class="viewcode-block" id="find_neighbors2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.find_neighbors2">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">find_neighbors2</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">cracks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the neigbors of point i that are in range of delta. The funtions works on multidimensional points. The same as find_neighbors2 but allows for cracks.</span>
<span class="sd">    Inputs:</span>
<span class="sd">    -----------</span>
<span class="sd">    coords : array of array of floats (coordinates of points=. shape = [number of points, dimensionality of points]. Coordinates should be floats.</span>
<span class="sd">    r      : radius of includivity. Points j that are distanced r or less, from point i, are considered to be members of point i. Should be float</span>
<span class="sd">    cracks : 2d array of floats. Contains the couples of points that define all the cracks inthe model. shape = [number of crack lines,2]</span>
<span class="sd">                example: cracks = [[[x0,y0],[x1,y1]],</span>
<span class="sd">                                   [[x2,y2],[x3,y3]]]  -&gt; [x0,y0] is the first point of the crack 0th crack, and [x1,y1] is the second point</span>
<span class="sd">    Outputs:</span>
<span class="sd">    -----------</span>
<span class="sd">    neighbors   : 1D array of floats (ID numbers of points). Contains the ID&#39;s of the neighbors of all points starting with the ID&#39;s of neighbors of point 0.</span>
<span class="sd">    start_index : 1D array of ints. Component &quot;i&quot; of the start_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; start.</span>
<span class="sd">    end_index   : 1D array of ints. Component &quot;i&quot; of the end_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; end.</span>
<span class="sd">    n_neighbors : 1D array of ints. Component &quot;i&quot; contains the number of neighbors that the point with ID = &quot;i&quot; has.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_neighbors</span> <span class="o">=</span> <span class="mi">120</span> <span class="c1"># This should change based on the dimensionality of the points. 28 is just for 2d and delta = 3 * dx.</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_points</span><span class="o">*</span><span class="n">max_neighbors</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">current_neighbor</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span><span class="o">!=</span><span class="n">j</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">dist</span> <span class="o">+=</span> <span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">alive</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">for</span> <span class="n">curcrack</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cracks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="c1">#if intersect2(point1 of crack,point2 of crack,point1 of bond,point2 of crack)</span>
                        <span class="n">alive</span> <span class="o">=</span> <span class="n">alive</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">intersect2</span><span class="p">(</span><span class="n">cracks</span><span class="p">[</span><span class="n">curcrack</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">cracks</span><span class="p">[</span><span class="n">curcrack</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="c1">#first the cracks then the point</span>
                    <span class="k">if</span> <span class="n">alive</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">neighbors</span><span class="p">[</span><span class="n">current_neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="n">n_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">current_neighbor</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">end_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">)</span>
    <span class="n">start_index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">end_index</span><span class="p">[:</span><span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">neighbors</span><span class="p">[:</span><span class="n">end_index</span><span class="p">[</span><span class="n">n_points</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">start_index</span><span class="p">,</span><span class="n">end_index</span><span class="p">,</span> <span class="n">n_neighbors</span></div>


<div class="viewcode-block" id="ccw2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.ccw2">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">ccw2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">):</span>
	<span class="c1">#return (C.y-A.y)*(B.x-A.x) &gt; (B.y-A.y)*(C.x-A.x)</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">&gt;</span><span class="p">((</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span></div>

<div class="viewcode-block" id="intersect2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.intersect2">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">intersect2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">):</span>
	<span class="c1">#return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D)</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ccw2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ccw2</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ccw2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ccw2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">D</span><span class="p">))</span></div>


<div class="viewcode-block" id="tse_terms">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.tse_terms">[docs]</a>
<span class="k">def</span> <span class="nf">tse_terms</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the number of TSE terms based on the dimensionality of PD points &quot;M&quot; and the specified maximum order of TSE terms &quot;N&quot;</span>
<span class="sd">    M must! be higher or equal to N. The output includes the term x1^0 * x2^0 * ... * xi^0. For a relative function PDDO the output need to be</span>
<span class="sd">    lowered by 1.</span>
<span class="sd">    Inputs:</span>
<span class="sd">    ---------</span>
<span class="sd">    M : int. Dimensionality of pd points</span>
<span class="sd">    N : int. Maximum order of TSE terms</span>

<span class="sd">    Output:</span>
<span class="sd">    ---------</span>
<span class="sd">    D : int. Number of tse terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">n</span><span class="o">=</span><span class="n">N</span>
    <span class="k">def</span> <span class="nf">loop1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">D</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">loop1</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">M</span><span class="p">:</span>
                    <span class="n">D</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">D</span>
    <span class="k">return</span> <span class="n">loop1</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="tse_pows">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.tse_pows">[docs]</a>
<span class="k">def</span> <span class="nf">tse_pows</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">D</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the powers of each xsi of each component of xsi (each dimension of xsi) and for each TSE term.</span>
<span class="sd">    Xsi represents a bond. Another way to look at a bond is simply as a connection between two points in a family.</span>
<span class="sd">    Since xsi is a connection it has some length in every dimension so it is a vector of relative position between two points</span>
<span class="sd">    with vector components xsi = (xsi1,xsi2,xsi3,..,xsiM)! -&gt; could also be wirtten as xsi = (x,y,z,..,t), but this way you quickly</span>
<span class="sd">    run out of characters to represent dimensions.</span>

<span class="sd">    Inputs:</span>
<span class="sd">    ---------</span>
<span class="sd">    M : int. Dimensionality of pd points</span>
<span class="sd">    N : int. Maximum order of TSE terms</span>
<span class="sd">    D : int. Number of tse terms.</span>

<span class="sd">    Output:</span>
<span class="sd">    ---------</span>
<span class="sd">    p : 2d array[:,:]. Contains the powers of each xsi of each component of xsi (each dimension of xsi) and for each TSE term.</span>
<span class="sd">                        p.shape[0] = &quot;number of tse terms&quot;.</span>
<span class="sd">                        p.shape[1] = &quot;M&quot; (the dimensionllality of the points).</span>
<span class="sd">                            Each column in &quot;p&quot; (p[:,m]) contains the powers for one component of xsi.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">icount</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">#A counter that keeps track of the current number of bonds, while looping through each points and finding their family membrs.</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span><span class="n">M</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">num1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="c1"># Temporary parameter</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="c1"># Temporary parameter</span>
    <span class="n">m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">n</span><span class="o">=</span><span class="n">N</span>

    <span class="k">def</span> <span class="nf">loop2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">icount</span>
        <span class="k">nonlocal</span> <span class="n">p</span>
        <span class="k">nonlocal</span> <span class="n">M</span>
        <span class="n">num1</span><span class="o">=</span><span class="n">num</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">m</span><span class="o">&lt;=</span><span class="n">M</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">num1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
                <span class="n">loop2</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="n">num1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">==</span><span class="n">M</span><span class="p">:</span>
                    <span class="n">icount</span> <span class="o">=</span> <span class="n">icount</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">icount</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">num1</span><span class="p">[</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


        <span class="k">return</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">loop2</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">num</span><span class="p">)</span></div>


<div class="viewcode-block" id="axis1prod">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.axis1prod">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">axis1prod</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">array</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="axis1fact">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.axis1fact">[docs]</a>
<span class="k">def</span> <span class="nf">axis1fact</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">axis1prod</span><span class="p">(</span><span class="n">factorial</span><span class="p">(</span><span class="n">array</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="matinv">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.matinv">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">matinv</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_bmat">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_bmat">[docs]</a>
<span class="k">def</span> <span class="nf">gen_bmat</span><span class="p">(</span><span class="n">porders</span><span class="p">,</span><span class="n">pows</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to compute the right hand side vector (or matrix if you want to compute more than 1 derivative). Relative function!</span>
<span class="sd">    Inputs</span>
<span class="sd">    -------</span>
<span class="sd">    porders: 2d array of floats. Contains the orders of differentiation for each dimension.</span>
<span class="sd">                porders.shape =[number of derivatives wanted/stated, dimensionality]</span>
<span class="sd">                porders = [[1,2],[0,1]] -&gt;</span>
<span class="sd">                proders[0,0] = order of differentiraion for 1st dimension for the first derivation</span>
<span class="sd">                proders[0,1] = order of differentiraion for 2st dimension for the first derivation</span>
<span class="sd">                proders[1,0] = order of differentiraion for 1st dimension for the second derivation</span>
<span class="sd">                proders[1,1] = order of differentiraion for 2st dimension for the second derivation</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    bmat: 2d array of floats. Contains the RHS vector/matrix. bmat.shape = [number of TSE terms,number of derrivatives to compute]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TSElen</span> <span class="o">=</span> <span class="n">pows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">pows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">numdfs</span> <span class="o">=</span> <span class="n">porders</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># number of derivative combinations to compute</span>
    <span class="c1"># Compute the factorial terms for each TSE term</span>
    <span class="n">bfacts</span> <span class="o">=</span> <span class="n">axis1fact</span><span class="p">(</span><span class="n">pows</span><span class="p">)</span>
    <span class="c1"># Find which combination of powers in &quot;pows&quot; matches the powers given in &quot;porders&quot;</span>
    <span class="c1"># Need to check each derivation in porders</span>
    <span class="n">bmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">TSElen</span><span class="p">,</span><span class="n">numdfs</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numdfs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">TSElen</span><span class="p">):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">porders</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pows</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">m</span><span class="p">]:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">bmat</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bfacts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">bmat</span></div>




<div class="viewcode-block" id="gen_gComponents">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_gComponents">[docs]</a>
<span class="k">def</span> <span class="nf">gen_gComponents</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">porders</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the &quot;a&quot; coeffs, powers(xsi_i) of xsi components and weights(xsi) of g(xsi) functions, for a relative function.</span>
<span class="sd">    If vols = 1, then the volume of each point is computed assuming we have a regular M dimensional grid</span>
<span class="sd">    Inputs</span>
<span class="sd">    -------</span>
<span class="sd">    coords  : 2d array of floats. Coordinates of points --&gt;coords.shape = [number of points, dimensionality of points].</span>
<span class="sd">    porders: 2d array of floats. Contains the orders of differentiation for each dimension.</span>
<span class="sd">                porders.shape =[number of derivatives wanted/stated, dimensionality]</span>
<span class="sd">                porders = [[1,2],[0,1]] -&gt;</span>
<span class="sd">                proders[0,0] = order of differentiraion for 1st dimension for the first derivation</span>
<span class="sd">                proders[0,1] = order of differentiraion for 2st dimension for the first derivation</span>
<span class="sd">                proders[1,0] = order of differentiraion for 1st dimension for the second derivation</span>
<span class="sd">                proders[1,1] = order of differentiraion for 2st dimension for the second derivation</span>

<span class="sd">    N : int. Maximum order of TSE terms</span>
<span class="sd">    delta : float. Radius of the horizon of point families</span>
<span class="sd">    vols :  array of floats. Contains the volume of each point. vols.shape = [number of points].</span>
<span class="sd">            If &quot;vols&quot; is not provided in inputs, it is assumed that each points has the same volume and that the domain is regularly discretized.</span>
<span class="sd">            The &quot;vols&quot; is thus filled with a single number computed as the product of the discretization step sizes for each dimension</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    ptavecs : 3d array of floats. Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms]</span>

<span class="sd">    pvec : 2d array of floats. Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">            pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms]</span>

<span class="sd">    weight : 1d array of floats. Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">tse_terms</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="c1">#compute the number of tse terms</span>
    <span class="n">pows</span> <span class="o">=</span> <span class="n">tse_pows</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">D</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,:]</span>  <span class="c1"># compute the powers of x,y,z,...n, for each term</span>
    <span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="mf">1.01</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="c1"># 1) compute the 1D vector of families, 2) the indexes at which each family starts in coords, 3)the indexes at which each family ends in coords, 4)and the numnber of neighbors</span>

    <span class="c1"># Amat = np.zeros((D,D),dtype=np.float64)</span>
    <span class="c1"># Ainv = np.zeros((D,D),dtype=np.float64)</span>

    <span class="c1">## If the volume of each point is not specified in the inputs, the volume is calculated based on the domain discretization.</span>
    <span class="c1">## It is the product of the disretisation steps in each dimension -&gt; each points has the same volume as if the domain is unifrm</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">vols</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">vols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">vol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># for m in range(M):</span>
        <span class="c1">#     vol =vol * (coords[1,0]-coords[0,0])</span>
        <span class="n">vols</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vol</span>

    <span class="n">bmat</span> <span class="o">=</span> <span class="n">gen_bmat</span><span class="p">(</span><span class="n">porders</span><span class="p">,</span><span class="n">pows</span><span class="p">)</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span><span class="n">porders</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">D</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">D</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1">#end_idx[-1] is the number of xsi there are in the whole domain. fams.shape[0] is larger since we had to assume the maximum number of members for each point(not all families are full!)</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">end_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="nd">@njit</span>
    <span class="k">def</span> <span class="nf">avecsloop</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="p">,</span><span class="n">bmat</span><span class="p">,</span><span class="n">ptavecs</span><span class="p">,</span><span class="n">pvec</span><span class="p">,</span><span class="n">weight</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the things that are stated in the outer function. This function just goes through the actual computation, while the outer function</span>
<span class="sd">        prepares all the necessary data needed for the coputation. This function should never be called dirrectly</span>
<span class="sd">        Inputs:</span>
<span class="sd">        --------</span>
<span class="sd">        coords      : array of array of floats (coordinates of points=. shape = [number of points, dimensionality of points]. Coordinates should be floats.</span>
<span class="sd">        fams        : 1D array of floats (ID numbers of points). Contains the ID&#39;s of the neighbors of all points starting with the ID&#39;s of neighbors of point 0.</span>
<span class="sd">        start_idx   : 1D array of ints. Component &quot;i&quot; of the start_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; start.</span>
<span class="sd">        end_idx     : 1D array of ints. Component &quot;i&quot; of the end_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; end.</span>
<span class="sd">        delta   : float. Radius of the horizon of point families.</span>
<span class="sd">        vols    : array of floats. Contains the volume of each point. vols.shape = [number of points].</span>
<span class="sd">                    If &quot;vols&quot; is not provided in inputs, it is assumed that each points has the same volume and that the domain is regularly discretized.</span>
<span class="sd">                    The &quot;vols&quot; is thus filled with a single number computed as the product of the discretization step sizes for each dimension</span>
<span class="sd">        bmat    : 2d array of floats. Contains the RHS vector/matrix. bmat.shape = [number of TSE terms,number of derrivatives to compute]</span>
<span class="sd">        ptavecs : 3d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                    Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                    Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                    from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                    ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms].</span>

<span class="sd">        pvec    : 2d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                    Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">                    pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms]. Is empty at input. USedf as a container to write in</span>

<span class="sd">        weight : 1d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                 Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>
<span class="sd">                 Is empty at input. USedf as a container to write in</span>
<span class="sd">        Outputs:</span>
<span class="sd">        --------</span>
<span class="sd">        ptavecs : 3d array of floats. Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                    Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                    from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                    ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms]</span>

<span class="sd">        pvec    : 2d array of floats. Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">                    pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms].</span>

<span class="sd">        weight : 1d array of floats. Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span> <span class="c1">#range(n_points)</span>
            <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span><span class="n">D</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ptmemloc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span><span class="c1">#:range(start_idx[pt],end_idx[pt])</span>
                <span class="n">xsi</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">fams</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                <span class="n">ximag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xsi</span><span class="o">*</span><span class="n">xsi</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="c1">#based on a few custom loops i made, this line is around half the computational cost</span>
                <span class="c1">#Calculate the powers of components of xsi based on the TSE term powers</span>
                <span class="n">curpvec</span> <span class="o">=</span> <span class="n">axis1prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">xsi</span><span class="p">,</span><span class="n">pows</span><span class="p">))</span> <span class="c1"># used my own function because np.prod() is now support by numba if i want to use the axis=1 optional argument. My function is even faster!</span>
                <span class="c1">#print(xsi,curpvec)</span>
                <span class="c1">#Calculate the weight function for each xsi -&gt; w(xsi)</span>
                <span class="n">curweight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">ximag</span><span class="o">/</span><span class="n">delta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">Amat</span> <span class="o">=</span> <span class="n">Amat</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">curpvec</span><span class="p">,</span><span class="n">curpvec</span><span class="p">)</span><span class="o">*</span><span class="n">curweight</span><span class="o">*</span><span class="n">vols</span><span class="p">[</span><span class="n">fams</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]]</span>
                <span class="n">pvec</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">curpvec</span>
                <span class="n">weight</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">curweight</span>
                <span class="c1">#print(curweight)</span>
            <span class="c1">#End of A matrix computation</span>
            <span class="c1">#Find the inverse of the shape matrix for point &quot;pt&quot;</span>
            <span class="n">Ainv</span> <span class="o">=</span> <span class="n">matinv</span><span class="p">(</span><span class="n">Amat</span><span class="p">)</span>
            <span class="c1">#Write the g function parameters into ptgvecs array</span>
            <span class="c1">#print(np.linalg.cond(Amat))</span>
            <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ainv</span><span class="p">,</span><span class="n">bmat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">ptavecs</span><span class="p">,</span> <span class="n">pvec</span><span class="p">,</span> <span class="n">weight</span>
    <span class="k">return</span> <span class="n">avecsloop</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="p">,</span><span class="n">bmat</span><span class="p">,</span><span class="n">ptavecs</span><span class="p">,</span><span class="n">pvec</span><span class="p">,</span><span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_gComponents2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_gComponents2">[docs]</a>
<span class="k">def</span> <span class="nf">gen_gComponents2</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">porders</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the &quot;a&quot; coeffs, powers(xsi_i) of xsi components and weights(xsi) of g(xsi) functions, for a relative function.</span>
<span class="sd">    IT is different from the first &quot;gen_gComponents&quot; function only in the weight function. The wight here is w_n = (delta/|xsi|)n+1</span>
<span class="sd">    If vols = 1, then the volume of each point is computed assuming we have a regular M dimensional grid</span>
<span class="sd">    Inputs</span>
<span class="sd">    -------</span>
<span class="sd">    coords  : 2d array of floats. Coordinates of points --&gt;coords.shape = [number of points, dimensionality of points].</span>
<span class="sd">    porders: 2d array of floats. Contains the orders of differentiation for each dimension.</span>
<span class="sd">                porders.shape =[number of derivatives wanted/stated, dimensionality]</span>
<span class="sd">                porders = [[1,2],[0,1]] -&gt;</span>
<span class="sd">                proders[0,0] = order of differentiraion for 1st dimension for the first derivation</span>
<span class="sd">                proders[0,1] = order of differentiraion for 2st dimension for the first derivation</span>
<span class="sd">                proders[1,0] = order of differentiraion for 1st dimension for the second derivation</span>
<span class="sd">                proders[1,1] = order of differentiraion for 2st dimension for the second derivation</span>

<span class="sd">    N : int. Maximum order of TSE terms</span>
<span class="sd">    delta : float. Radius of the horizon of point families</span>
<span class="sd">    vols :  array of floats. Contains the volume of each point. vols.shape = [number of points].</span>
<span class="sd">            If &quot;vols&quot; is not provided in inputs, it is assumed that each points has the same volume and that the domain is regularly discretized.</span>
<span class="sd">            The &quot;vols&quot; is thus filled with a single number computed as the product of the discretization step sizes for each dimension</span>

<span class="sd">    Outputs</span>
<span class="sd">    -------</span>
<span class="sd">    ptavecs : 3d array of floats. Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms]</span>

<span class="sd">    pvec : 2d array of floats. Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">            pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms]</span>

<span class="sd">    weight : 1d array of floats. Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span><span class="o">=</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">tse_terms</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="c1">#compute the number of tse terms</span>
    <span class="n">pows</span> <span class="o">=</span> <span class="n">tse_pows</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">D</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,:]</span>  <span class="c1"># compute the powers of x,y,z,...n, for each term</span>
    <span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="mf">1.01</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="c1"># 1) compute the 1D vector of families, 2) the indexes at which each family starts in coords, 3)the indexes at which each family ends in coords, 4)and the numnber of neighbors</span>

    <span class="c1"># Amat = np.zeros((D,D),dtype=np.float64)</span>
    <span class="c1"># Ainv = np.zeros((D,D),dtype=np.float64)</span>

    <span class="c1">## If the volume of each point is not specified in the inputs, the volume is calculated based on the domain discretization.</span>
    <span class="c1">## It is the product of the disretisation steps in each dimension -&gt; each points has the same volume as if the domain is unifrm</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">vols</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
        <span class="n">vols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">vol</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># for m in range(M):</span>
        <span class="c1">#     vol =vol * (coords[1,0]-coords[0,0])</span>
        <span class="n">vols</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">vol</span>

    <span class="n">bmat</span> <span class="o">=</span> <span class="n">gen_bmat</span><span class="p">(</span><span class="n">porders</span><span class="p">,</span><span class="n">pows</span><span class="p">)</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span><span class="n">porders</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">D</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">D</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="c1">#end_idx[-1] is the number of xsi there are in the whole domain. fams.shape[0] is larger since we had to assume the maximum number of members for each point(not all families are full!)</span>
    <span class="n">weightvecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">D</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">powssum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pows</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">powMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">D</span><span class="p">,</span><span class="n">D</span><span class="p">),</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">powssum</span><span class="o">==</span><span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">powMat</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">powssum</span>
            <span class="n">powMat</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">powssum</span>

    <span class="nd">@njit</span>
    <span class="k">def</span> <span class="nf">avecsloop2</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="p">,</span><span class="n">bmat</span><span class="p">,</span><span class="n">ptavecs</span><span class="p">,</span><span class="n">pvec</span><span class="p">,</span><span class="n">powMat</span><span class="p">,</span><span class="n">weightvecs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the things that are stated in the outer function. This function just goes through the actual computation, while the outer function</span>
<span class="sd">        prepares all the necessary data needed for the coputation. This function should never be called dirrectly</span>
<span class="sd">        Inputs:</span>
<span class="sd">        --------</span>
<span class="sd">        coords      : array of array of floats (coordinates of points=. shape = [number of points, dimensionality of points]. Coordinates should be floats.</span>
<span class="sd">        fams        : 1D array of floats (ID numbers of points). Contains the ID&#39;s of the neighbors of all points starting with the ID&#39;s of neighbors of point 0.</span>
<span class="sd">        start_idx   : 1D array of ints. Component &quot;i&quot; of the start_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; start.</span>
<span class="sd">        end_idx     : 1D array of ints. Component &quot;i&quot; of the end_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; end.</span>
<span class="sd">        delta   : float. Radius of the horizon of point families.</span>
<span class="sd">        vols    : array of floats. Contains the volume of each point. vols.shape = [number of points].</span>
<span class="sd">                    If &quot;vols&quot; is not provided in inputs, it is assumed that each points has the same volume and that the domain is regularly discretized.</span>
<span class="sd">                    The &quot;vols&quot; is thus filled with a single number computed as the product of the discretization step sizes for each dimension</span>
<span class="sd">        bmat    : 2d array of floats. Contains the RHS vector/matrix. bmat.shape = [number of TSE terms,number of derrivatives to compute]</span>
<span class="sd">        ptavecs : 3d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                    Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                    Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                    from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                    ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms].</span>

<span class="sd">        pvec    : 2d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                    Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">                    pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms]. Is empty at input. USedf as a container to write in</span>

<span class="sd">        weight : 1d array of floats. Is empty at input. Used as a container to write in</span>
<span class="sd">                 Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>
<span class="sd">                 Is empty at input. USedf as a container to write in</span>
<span class="sd">        Outputs:</span>
<span class="sd">        --------</span>
<span class="sd">        ptavecs : 3d array of floats. Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                    Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                    from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                    ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms]</span>

<span class="sd">        pvecs    : 2d array of floats. Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">                    pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms].</span>

<span class="sd">        weight : 1d array of floats. Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span> <span class="c1">#range(n_points)</span>
            <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">D</span><span class="p">,</span><span class="n">D</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ptmemloc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span><span class="c1">#:range(start_idx[pt],end_idx[pt])</span>
                <span class="n">xsi</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">fams</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
                <span class="n">ximag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xsi</span><span class="o">*</span><span class="n">xsi</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="c1">#based on a few custom loops i made, this line is around half the computational cost</span>
                <span class="c1">#Calculate the powers of components of xsi based on the TSE term powers</span>
                <span class="n">curpvec</span> <span class="o">=</span> <span class="n">axis1prod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">xsi</span><span class="p">,</span><span class="n">pows</span><span class="p">))</span> <span class="c1"># used my own function because np.prod() is now support by numba if i want to use the axis=1 optional argument. My function is even faster!</span>
                <span class="c1">#print(xsi,curpvec)</span>
                <span class="c1">#Calculate the weight function for each xsi -&gt; w(xsi)</span>
                <span class="n">curweightMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="n">delta</span><span class="o">/</span><span class="n">ximag</span><span class="p">),</span><span class="n">powMat</span><span class="p">)</span>
                <span class="n">Amat</span> <span class="o">=</span> <span class="n">Amat</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">curpvec</span><span class="p">,</span><span class="n">curpvec</span><span class="p">)</span><span class="o">*</span><span class="n">curweightMat</span><span class="o">*</span><span class="n">vols</span><span class="p">[</span><span class="n">fams</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]]</span>
                <span class="n">pvec</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">curpvec</span>
                <span class="n">weightvecs</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">curweightMat</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1">#print(curweight)</span>
            <span class="c1">#End of A matrix computation</span>
            <span class="c1">#Find the inverse of the shape matrix for point &quot;pt&quot;</span>
            <span class="n">Ainv</span> <span class="o">=</span> <span class="n">matinv</span><span class="p">(</span><span class="n">Amat</span><span class="p">)</span>
            <span class="c1">#Write the g function parameters into ptgvecs array</span>
            <span class="c1">#print(np.linalg.cond(Amat))</span>
            <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ainv</span><span class="p">,</span><span class="n">bmat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">ptavecs</span><span class="p">,</span> <span class="n">pvec</span><span class="p">,</span> <span class="n">weightvecs</span>
    <span class="k">return</span> <span class="n">avecsloop2</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span><span class="n">fams</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">vols</span><span class="p">,</span><span class="n">bmat</span><span class="p">,</span><span class="n">ptavecs</span><span class="p">,</span><span class="n">pvec</span><span class="p">,</span><span class="n">powMat</span><span class="p">,</span><span class="n">weightvecs</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_xsigval">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_xsigval">[docs]</a>
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gen_xsigval</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">,</span><span class="n">pvec</span><span class="p">,</span><span class="n">weight</span><span class="p">,</span><span class="n">start_index</span><span class="p">,</span><span class="n">end_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the value of g functions for each xsi/bond and stores it in an array so that they dont need to be computed again for the same domain.</span>
<span class="sd">    The outputs of &quot;gen_gComponents()&quot; are meant to be input into this function -&gt; ptavecs,pvec,weight = gen_gComponents()</span>
<span class="sd">    Inputs</span>
<span class="sd">    -------</span>
<span class="sd">    ptavecs : 3d array of floats. Contains the values of &quot;a&quot; coefficients in g functions corresponding with the wanted/stated derivatives.</span>
<span class="sd">                    Since each point can have a different horizon shape and each point computes its Amat (which together with bmat defines the &quot;a&quot; coefficients),</span>
<span class="sd">                    from the bonds in the family, each point can have different &quot;a&quot; coefficients in its g functions.</span>
<span class="sd">                    ptavecs.shape = [number points,number of derivatives wanted/stated,number of TSE terms]</span>

<span class="sd">    pvec    : 2d array of floats. Contains the values of the product of xsi component powers for each TSE term for each xsi/bond.</span>
<span class="sd">                    pvec.shape = [numbers of xsi&#39;s/bonds,number of TSE terms]</span>

<span class="sd">    weight : 1d array of floats. Contains the values of the weight function for every xsi/bond. weight.shape = [number of xsi&#39;s/bonds]</span>

<span class="sd">    start_index   : 1D array of ints. Component &quot;i&quot; of the start_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; start.</span>
<span class="sd">    end_index     : 1D array of ints. Component &quot;i&quot; of the end_index array shows at which index, in the neighbors array, the neighbors of point with ID = &quot;i&quot; end.</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">end_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ptavecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">start_index</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">ptmemloc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_index</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span><span class="c1">#range(start_index[pt],end_index[pt]):</span>
            <span class="c1">#Calculate the value of g(xsi) for every xsi in domain</span>
            <span class="n">g</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">*</span> <span class="n">pvec</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="PDDOderive">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.PDDOderive">[docs]</a>
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span> <span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">PDDOderive</span><span class="p">(</span><span class="n">funvals</span><span class="p">,</span><span class="n">fams</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">vols</span><span class="p">,</span><span class="n">start_index</span><span class="p">,</span><span class="n">end_index</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">funvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">funvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">ptres</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">g</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">ptmemloc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_index</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_index</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="c1">#Calculate the value of g(xsi) for every xsi in domain</span>
            <span class="n">ptres</span> <span class="o">=</span> <span class="n">ptres</span><span class="o">+</span> <span class="p">(</span><span class="n">funvals</span><span class="p">[</span><span class="n">fams</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]]</span><span class="o">-</span><span class="n">funvals</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span><span class="o">*</span><span class="n">g</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span><span class="o">*</span><span class="n">vols</span><span class="p">[</span><span class="n">ptmemloc</span><span class="p">]</span>
            <span class="c1">#print(ptres,ptmemloc)</span>

        <span class="n">res</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptres</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="calc_bondLenghts">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.calc_bondLenghts">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">calc_bondLenghts</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to calculate the length of each bond based od points in coordVec.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bondLens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">famid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">sqsum</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">sqsum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">famid</span><span class="p">],</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">pt</span><span class="p">,</span><span class="n">m</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">curdist</span> <span class="o">=</span> <span class="n">sqsum</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">bondLens</span><span class="p">[</span><span class="n">famid</span><span class="p">]</span> <span class="o">=</span> <span class="n">curdist</span>
    <span class="k">return</span> <span class="n">bondLens</span></div>


<div class="viewcode-block" id="find_valueID">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.find_valueID">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">find_valueID</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span><span class="n">val</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span></div>


<div class="viewcode-block" id="gen_Gmat2D">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_Gmat2D">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">gen_Gmat2D</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function is flawed as of the 28/02/2024 github state. The inputs in the Amat are not</span>
<span class="sd">    multiplied by the area of ceah PD material point. Therefore the resulting calculation do not give a force density vector.&quot;&quot;&quot;</span>
    <span class="c1">#Calculate b matrix</span>
    <span class="n">bmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="c1">##g20</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g02</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g11</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">#Calculate the a parameters for g functions of G matrix</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">xsiweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Amat</span><span class="p">[:,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">xsi</span> <span class="o">=</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="n">xsiX</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xsiY</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">xsimag</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xsiweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">/</span><span class="n">xsimag</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span> <span class="o">*</span> <span class="n">xsiY</span>
            <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiweight</span>
        <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#Matrix conditioning Q@A@Q @ Qinv@a = Q@b</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Qvec</span><span class="p">)</span>
        <span class="n">QAmatQ</span> <span class="o">=</span>  <span class="n">Q</span><span class="nd">@Amat@Q</span>
        <span class="n">Qbmat</span> <span class="o">=</span> <span class="n">Q</span><span class="nd">@bmat</span>

        <span class="n">QAmatQinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">QAmatQ</span><span class="p">)</span>
        <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="nd">@np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QAmatQinv</span><span class="p">,</span><span class="n">Qbmat</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#Create the values of g for each xsi</span>
    <span class="n">G_xsigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ptavecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">G_xsigvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">*</span> <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_xsigvals</span></div>


<div class="viewcode-block" id="gen_Gmat2D_fixed">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_Gmat2D_fixed">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">gen_Gmat2D_fixed</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">area</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Non:_fixed function :This function is flawed as of the 28/02/2024 github state. The inputs in the Amat are not</span>
<span class="sd">    multiplied by the area of each PD material point. Therefore the resulting calculation do not give a force density vector.</span>
<span class="sd">    --------</span>
<span class="sd">    This _fixed function has the area part in the calculation. Need to cehck if it is correct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Calculate b matrix</span>
    <span class="n">bmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="c1">##g20</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g02</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g11</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">#Calculate the a parameters for g functions of G matrix</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">xsiweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Amat</span><span class="p">[:,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">xsi</span> <span class="o">=</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="n">xsiX</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xsiY</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">xsimag</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xsiweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">/</span><span class="n">xsimag</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span> <span class="o">*</span> <span class="n">xsiY</span>
            <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiweight</span>
        <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#Matrix conditioning Q@A@Q @ Qinv@a = Q@b</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Qvec</span><span class="p">)</span>
        <span class="n">QAmatQ</span> <span class="o">=</span>  <span class="n">Q</span><span class="nd">@Amat@Q</span>
        <span class="n">Qbmat</span> <span class="o">=</span> <span class="n">Q</span><span class="nd">@bmat</span>

        <span class="n">QAmatQinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">QAmatQ</span><span class="p">)</span>
        <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="nd">@np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QAmatQinv</span><span class="p">,</span><span class="n">Qbmat</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#Create the values of g for each xsi</span>
    <span class="n">G_xsigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ptavecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">G_xsigvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">*</span> <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_xsigvals</span></div>


<div class="viewcode-block" id="gen_Gmat2D_fixed2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_Gmat2D_fixed2">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">gen_Gmat2D_fixed2</span><span class="p">(</span><span class="n">coordVec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">neighbors</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">delta</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">area</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This function is does the same as gen_Gmat2D except for the fact that it takes the volume into account when creating A matrices.</span>
<span class="sd">        Also in this implementation of this function, the area of EACH point is used and not a homogenous area across all points.</span>
<span class="sd">    --------</span>
<span class="sd">    This _fixed function has the area part in the calculation. Need to check if it is correct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Calculate b matrix</span>
    <span class="n">bmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="c1">##g20</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g02</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g11</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1">#Calculate the a parameters for g functions of G matrix</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">xsiweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Amat</span><span class="p">[:,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">xsi</span> <span class="o">=</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="n">xsiX</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xsiY</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">xsimag</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xsiweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">/</span><span class="n">xsimag</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span> <span class="c1">#* area[neighbors[j]] # I can just multiply with the area here once instead of 4 times below!</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span> <span class="o">*</span> <span class="n">xsiY</span>
            <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiweight</span>
        <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#Matrix conditioning Q@A@Q @ Qinv@a = Q@b</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Qvec</span><span class="p">)</span>
        <span class="n">QAmatQ</span> <span class="o">=</span>  <span class="n">Q</span><span class="nd">@Amat@Q</span>
        <span class="n">Qbmat</span> <span class="o">=</span> <span class="n">Q</span><span class="nd">@bmat</span>

        <span class="n">QAmatQinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">QAmatQ</span><span class="p">)</span>
        <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="nd">@np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QAmatQinv</span><span class="p">,</span><span class="n">Qbmat</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#Create the values of g for each xsi</span>
    <span class="n">G_xsigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ptavecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">G_xsigvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">*</span> <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_xsigvals</span></div>



<div class="viewcode-block" id="gen_Gmat3D">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_Gmat3D">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">gen_Gmat3D</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">):</span>
    <span class="s2">&quot;&quot;</span>
    <span class="c1">#Calculate b matrix</span>
    <span class="n">bmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
    <span class="c1">##g200</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g020</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g002</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1">##g110</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">##g101</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">##g011</span>
    <span class="n">bmat</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>


    <span class="c1">#Calculate the a parameters for g functions of G matrix</span>
    <span class="n">ptavecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">Amat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">xsiweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">pvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">))</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">Qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Amat</span><span class="p">[:,:]</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">xsi</span> <span class="o">=</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>
            <span class="n">xsiX</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xsiY</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">xsiZ</span> <span class="o">=</span> <span class="n">xsi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">xsimag</span> <span class="o">=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xsiZ</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xsiweight</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span><span class="o">/</span><span class="n">xsimag</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span>

            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xsiZ</span><span class="o">**</span><span class="mi">4</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">*</span><span class="n">xsiY</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiX</span> <span class="o">*</span><span class="n">xsiZ</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiY</span> <span class="o">*</span><span class="n">xsiZ</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>

            <span class="n">Amat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">*</span><span class="n">xsiY</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiX</span><span class="o">*</span><span class="n">xsiZ</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>
            <span class="n">Amat</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">xsiY</span><span class="o">*</span><span class="n">xsiZ</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">xsiweight</span> <span class="c1">#</span>


            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiY</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiZ</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span> <span class="o">*</span> <span class="n">xsiY</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiX</span> <span class="o">*</span> <span class="n">xsiZ</span>
            <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiY</span> <span class="o">*</span> <span class="n">xsiZ</span>
            <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsiweight</span>

        <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1">#Matrix conditioning Q@A@Q @ Qinv@a = Q@b</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">Qvec</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Amat</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">Q</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Qvec</span><span class="p">)</span>
        <span class="n">QAmatQ</span> <span class="o">=</span>  <span class="n">Q</span><span class="nd">@Amat@Q</span>
        <span class="n">Qbmat</span> <span class="o">=</span> <span class="n">Q</span><span class="nd">@bmat</span>

        <span class="n">QAmatQinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">QAmatQ</span><span class="p">)</span>
        <span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">Q</span><span class="nd">@np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">QAmatQinv</span><span class="p">,</span><span class="n">Qbmat</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

    <span class="c1">#Create the values of g for each xsi</span>
    <span class="n">G_xsigvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ptavecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">G_xsigvals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ptavecs</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">*</span> <span class="n">pvec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_xsigvals</span></div>



<span class="c1"># ----------- Mehcanics part --------------------------------------------------------#</span>
<div class="viewcode-block" id="gen_StiffMat">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_StiffMat">[docs]</a>
<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">gen_StiffMat</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">Emod</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Emod</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mf">0.25</span><span class="p">)))</span>
    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="mf">1.01</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">Gvec</span> <span class="o">=</span> <span class="n">gen_Gmat2D</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">G11vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G12vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">G22vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="c1">#Calculate S for the bond between point &quot;j&quot; in family of &quot;pt&quot;</span>
            <span class="n">G11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G11G22</span> <span class="o">=</span> <span class="n">G11</span><span class="o">+</span><span class="n">G22</span>
            <span class="n">S11</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G11</span>
            <span class="n">S12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G12</span>
            <span class="n">S22</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G22</span>

            <span class="c1">#Calculate S for the bond petween point &quot;pt&quot; in family of &quot;j&quot;</span>
            <span class="n">j_pt</span> <span class="o">=</span> <span class="n">find_valueID</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span><span class="n">end_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]],</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">jG11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG11G22</span> <span class="o">=</span> <span class="n">jG11</span><span class="o">+</span><span class="n">jG22</span>
            <span class="n">jS11</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG11</span>
            <span class="n">jS12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG12</span>
            <span class="n">jS22</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG22</span>

            <span class="c1">#Calculate Sbar for bond pt_j (pt is main point j in fam member)</span>
            <span class="n">Sbar11</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S11</span><span class="o">+</span><span class="n">jS11</span><span class="p">)</span>
            <span class="n">Sbar12</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S12</span><span class="o">+</span><span class="n">jS12</span><span class="p">)</span>
            <span class="n">Sbar22</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S22</span><span class="o">+</span><span class="n">jS22</span><span class="p">)</span>

            <span class="c1">#Sum of contibutions of main point in every Xsi</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar11</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar22</span>

            <span class="c1">#Contributions of family members of main point</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar11</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar22</span>

    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="o">*</span><span class="n">mu</span>
    <span class="k">return</span> <span class="n">stiffMat</span></div>


<div class="viewcode-block" id="gen_StiffMat3D">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.gen_StiffMat3D">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">gen_StiffMat3D</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">delta</span><span class="p">,</span><span class="n">Emod</span><span class="p">):</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">Emod</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mf">0.25</span><span class="p">)))</span>
    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">n_neighbors</span> <span class="o">=</span> <span class="n">find_neighbors</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="mf">1.01</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">Gvec</span> <span class="o">=</span> <span class="n">gen_Gmat3D</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span><span class="n">start_idx</span><span class="p">,</span><span class="n">end_idx</span><span class="p">,</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">G11vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G22vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">G33vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">G12vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">G13vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">G23vec</span> <span class="o">=</span> <span class="n">Gvec</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="c1">#Calculate S for the bond between point &quot;j&quot; in family of &quot;pt&quot;</span>
            <span class="n">G11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G13</span> <span class="o">=</span> <span class="n">G13vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G22</span> <span class="o">=</span> <span class="n">G22vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G23</span> <span class="o">=</span> <span class="n">G23vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">G33</span> <span class="o">=</span> <span class="n">G33vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">G11G22G33</span> <span class="o">=</span> <span class="n">G11</span><span class="o">+</span><span class="n">G22</span><span class="o">+</span><span class="n">G33</span>
            <span class="n">S11</span> <span class="o">=</span> <span class="n">G11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G11</span>
            <span class="n">S22</span> <span class="o">=</span> <span class="n">G11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G22</span>
            <span class="n">S33</span> <span class="o">=</span> <span class="n">G11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G33</span>
            <span class="n">S12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G12</span>
            <span class="n">S13</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G13</span>
            <span class="n">S23</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G23</span>

            <span class="c1">#Calculate S for the bond petween point &quot;pt&quot; in family of &quot;j&quot;</span>
            <span class="n">j_pt</span> <span class="o">=</span> <span class="n">find_valueID</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span><span class="n">end_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]],</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">jG11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG13</span> <span class="o">=</span> <span class="n">G13vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG23</span> <span class="o">=</span>  <span class="n">G23vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
            <span class="n">jG33</span> <span class="o">=</span>  <span class="n">G33vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>

            <span class="n">jG11G22G33</span> <span class="o">=</span> <span class="n">jG11</span><span class="o">+</span><span class="n">jG22</span><span class="o">+</span><span class="n">jG33</span>
            <span class="n">jS11</span> <span class="o">=</span> <span class="n">jG11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG11</span>
            <span class="n">jS22</span> <span class="o">=</span> <span class="n">jG11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG22</span>
            <span class="n">jS33</span> <span class="o">=</span> <span class="n">jG11G22G33</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG33</span>
            <span class="n">jS12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG12</span>
            <span class="n">jS13</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG13</span>
            <span class="n">jS23</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG23</span>


            <span class="c1">#Calculate Sbar for bond pt_j (pt is main point j in fam member)</span>
            <span class="n">Sbar11</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S11</span><span class="o">+</span><span class="n">jS11</span><span class="p">)</span>
            <span class="n">Sbar12</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S12</span><span class="o">+</span><span class="n">jS12</span><span class="p">)</span>
            <span class="n">Sbar13</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S13</span><span class="o">+</span><span class="n">jS13</span><span class="p">)</span>
            <span class="n">Sbar22</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S22</span><span class="o">+</span><span class="n">jS22</span><span class="p">)</span>
            <span class="n">Sbar23</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S23</span><span class="o">+</span><span class="n">jS23</span><span class="p">)</span>
            <span class="n">Sbar33</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S33</span><span class="o">+</span><span class="n">jS33</span><span class="p">)</span>

            <span class="c1">#Sum of contibutions of main point in every Xsi</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar11</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar13</span>

            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar22</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar23</span>

            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar13</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar23</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar33</span>

            <span class="c1">#Contributions of family members of main point</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar11</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar13</span>

            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar12</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar22</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar23</span>

            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar13</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar23</span>
            <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar33</span>

    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="o">*</span><span class="n">mu</span>
    <span class="k">return</span> <span class="n">stiffMat</span></div>


<div class="viewcode-block" id="applyDispBC">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.applyDispBC">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">applyDispBC</span><span class="p">(</span><span class="n">BCvec</span><span class="p">,</span><span class="n">stiffnessMat</span><span class="p">,</span><span class="n">RHSvec</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply displacement boundary conditions to the global stiffnes matrix and RHS vector.</span>
<span class="sd">    Inputs:</span>
<span class="sd">    -------</span>
<span class="sd">    BCvec : 2d array of floats. Contains the points for which displacement BC will be applied to and the boundary conditions that will be applied to them. BCvec.shape = [number of constrained points, number of constrained DOF]</span>
<span class="sd">                BCvec.shape[0] -&gt; contains point ID&#39;s from the discretization. POints with the ID writen here get constrained</span>
<span class="sd">                BCvec.shape[1] -&gt; for 2d, this dimension is of length 2 or 3. The first input in the ID&#39;s, the second is the X direction constraints and third the Y direction constraints.</span>

<span class="sd">    stiffnessMat : 2d array of floats. The stiffness matrix created using the &quot;pddo.gen_StiffMat()&quot; function. stiffnessMat.shape = [number of points in discretization * 2, number of points in discretization * 2] = [number of DOF, number of DOF] -&gt; for 2D</span>
<span class="sd">                    This stiffness matrix does not have any BC applied to it!</span>

<span class="sd">    RHSvec : 1d array of floats. Array of zeros to be used to construct the RHS vector with applied BC&#39;s. RHSvec.shape = [number of DOF]</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    BCstiffnessMat : 2d array of floats. The stiffness matrix from the inputs but with BC&#39;s applied! BCstiffnessMat.shape = [number of DOF,number of DOF]</span>

<span class="sd">    RHSvec : 1d array of floats. The RHS vector from the inputs but with applied BC&#39;s. RHSvec.shape = [number of DOF]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">BCvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># 3 because the first (zeroth in python) column are ID&#39;s</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">BCvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># 4 because the first (zeroth in python) column are ID&#39;s</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BCvec is of wrong dimensions.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stiffnessMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">RHSvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">BCpts</span>  <span class="o">=</span> <span class="n">BCvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">BCdofs</span> <span class="o">=</span> <span class="n">BCvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="c1">#This is the number of DOF which are constrained in the BCs</span>
        <span class="n">BCstiffnessMat</span> <span class="o">=</span> <span class="n">stiffnessMat</span>
        <span class="n">RHSvec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">RHSvec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">BCpts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">locdof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCdofs</span><span class="p">):</span>
                <span class="n">globdof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">pt</span><span class="o">*</span><span class="n">dim</span> <span class="o">+</span> <span class="n">locdof</span><span class="p">)</span>
                <span class="n">RHSvec2cur</span> <span class="o">=</span> <span class="n">BCstiffnessMat</span><span class="p">[:,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">*</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#Modification of the RHS Vector to be added to the RHS vector outside of the outer loop</span>
                <span class="n">RHSvec2</span> <span class="o">=</span> <span class="n">RHSvec2</span> <span class="o">+</span> <span class="n">RHSvec2cur</span>
                <span class="n">RHSvec</span><span class="p">[</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1">#Modify the stiffnes matrix</span>
                <span class="n">BCstiffnessMat</span><span class="p">[:,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">BCstiffnessMat</span><span class="p">[</span><span class="n">globdof</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">BCstiffnessMat</span><span class="p">[</span><span class="n">globdof</span><span class="p">,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">RHSvec</span> <span class="o">=</span> <span class="n">RHSvec</span> <span class="o">-</span> <span class="n">RHSvec2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">BCpts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">locdof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCdofs</span><span class="p">):</span>
                <span class="n">globdof</span> <span class="o">=</span> <span class="n">pt</span><span class="o">*</span><span class="n">dim</span> <span class="o">+</span> <span class="n">locdof</span>
                <span class="n">RHSvec</span><span class="p">[</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BCstiffnessMat</span><span class="p">,</span><span class="n">RHSvec</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dimensions of stiffness matrix do not match dimensions of the RHS vector!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="applyDispBC2">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.applyDispBC2">[docs]</a>
<span class="k">def</span> <span class="nf">applyDispBC2</span><span class="p">(</span><span class="n">BCvec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">stiffnessMat</span><span class="p">:</span>  <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">RHSvec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply displacement boundary conditions to the global stiffnes matrix and RHS vector.</span>
<span class="sd">        Works for many combined BCloads together.</span>
<span class="sd">    Inputs:</span>
<span class="sd">    -------</span>
<span class="sd">    BCvec : 2d array of floats. Contains the points for which displacement BC will be applied to and the boundary conditions that will be applied to them. BCvec.shape = [number of constrained points, number of constrained DOF]</span>
<span class="sd">                BCvec[:,0] -&gt; contains point ID&#39;s from the discretization. Points with the ID writen here get constrained</span>
<span class="sd">                BCvec[:,1:4] -&gt; contains bool&#39;s to see if the DOF is contrained. BCvec[:,1] -&gt; DOF 0, BCvec[:,2] -&gt; DOF 1, BCvec[:,2] -&gt; DOF 3.</span>
<span class="sd">                BCvec[:,4:7] -&gt; contains the value of the applied displacement for DOF&#39;s from BCvec[:,1:4]</span>

<span class="sd">    stiffnessMat : 2d array of floats. The stiffness matrix created using the &quot;pddo.gen_StiffMat()&quot; function. stiffnessMat.shape = [number of points in discretization * 2, number of points in discretization * 2] = [number of DOF, number of DOF] -&gt; for 2D</span>
<span class="sd">                    This stiffness matrix does not have any BC applied to it!</span>

<span class="sd">    RHSvec : 1d array of floats. Array of zeros to be used to construct the RHS vector with applied BC&#39;s. RHSvec.shape = [number of DOF]</span>

<span class="sd">    Outputs:</span>
<span class="sd">    --------</span>
<span class="sd">    BCstiffnessMat : 2d array of floats. The stiffness matrix from the inputs but with BC&#39;s applied! BCstiffnessMat.shape = [number of DOF,number of DOF]</span>

<span class="sd">    RHSvec : 1d array of floats. The RHS vector from the inputs but with applied BC&#39;s. RHSvec.shape = [number of DOF]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stiffnessMat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">RHSvec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">BCpts</span>  <span class="o">=</span> <span class="n">BCvec</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">BCdofs</span> <span class="o">=</span> <span class="n">dim</span> <span class="c1">#This is the number of DOF which are constrained in the BCs</span>
        <span class="n">BCstiffnessMat</span> <span class="o">=</span> <span class="n">stiffnessMat</span>
        <span class="n">RHSvec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">RHSvec</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">BCpts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">locdof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCdofs</span><span class="p">):</span>
                <span class="n">locdof_isFixed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">locdof_isFixed</span><span class="p">:</span>
                    <span class="n">globdof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">pt</span><span class="o">*</span><span class="n">dim</span> <span class="o">+</span> <span class="n">locdof</span><span class="p">)</span>
                    <span class="n">RHSvec2cur</span> <span class="o">=</span> <span class="n">BCstiffnessMat</span><span class="p">[:,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">*</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>

                    <span class="c1">#Modification of the RHS Vector to be added to the RHS vector outside of the outer loop</span>
                    <span class="n">RHSvec2</span> <span class="o">=</span> <span class="n">RHSvec2</span> <span class="o">+</span> <span class="n">RHSvec2cur</span>
                    <span class="n">RHSvec</span><span class="p">[</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>

                    <span class="c1">#Modify the stiffnes matrix</span>
                    <span class="n">BCstiffnessMat</span><span class="p">[:,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">BCstiffnessMat</span><span class="p">[</span><span class="n">globdof</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">BCstiffnessMat</span><span class="p">[</span><span class="n">globdof</span><span class="p">,</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">RHSvec</span> <span class="o">=</span> <span class="n">RHSvec</span> <span class="o">-</span> <span class="n">RHSvec2</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCpts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">BCpts</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">locdof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">BCdofs</span><span class="p">):</span>
                <span class="n">globdof</span> <span class="o">=</span> <span class="n">pt</span><span class="o">*</span><span class="n">dim</span> <span class="o">+</span> <span class="n">locdof</span>
                <span class="n">RHSvec</span><span class="p">[</span><span class="n">globdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">BCvec</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">locdof</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BCstiffnessMat</span><span class="p">,</span><span class="n">RHSvec</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dimensions of stiffness matrix do not match dimensions of the RHS vector!&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_bond_normals">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.calc_bond_normals">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">calc_bond_normals</span><span class="p">(</span><span class="n">pd_point_count</span><span class="p">,</span> <span class="n">pd_bond_count</span><span class="p">,</span> <span class="n">coordVec</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">):</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">pd_bond_count</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pd_point_count</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bondid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">point</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">point</span><span class="p">]):</span>
                <span class="c1">#Calculate relative vector between teo points</span>
                <span class="n">_rel_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">coordVec</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">-</span> <span class="n">coordVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">bondid</span><span class="p">]])</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">_rel_vec</span><span class="o">/</span><span class="p">(</span><span class="n">_rel_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">_rel_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
                <span class="n">normals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">normal</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">normals</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve the current incremental load for equilibrium using Newton-Rhapson method.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">num_max_it</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">num_max_it</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The maximum number of iterations can not be a negative value and it must be an integer type!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epsilon</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Epsilon can not be a negative value! Epsilon == 0 is not realistic and must be larger! (0 &lt; epsilon)&quot;</span><span class="p">)</span>

        <span class="c1">#This for loop will need to be changed for a while loop eventually!</span>
        <span class="n">_RHSvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">_newCoordVec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">coordVec</span>
        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_max_it</span><span class="p">):</span><span class="c1"># and error &gt; epsilon:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration </span><span class="si">{</span><span class="nb">iter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1">#Create stiffness matrix and external force vector for current displacements</span>
            <span class="n">_stiffmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_stiffness_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curLiveBonds</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curBondDamage</span><span class="p">)</span>
            <span class="c1">#Apply boudary conditions</span>
            <span class="k">if</span> <span class="nb">iter</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">_BC_stiffmat</span><span class="p">,</span><span class="n">_BC_RHSvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_displacement_BC</span><span class="p">(</span><span class="n">BCvec</span><span class="p">,</span><span class="n">_stiffmat</span><span class="p">,</span><span class="n">_RHSvec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">BCvec</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">_BC_stiffmat</span><span class="p">,</span><span class="n">_BC_RHSvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_displacement_BC</span><span class="p">(</span><span class="n">BCvec</span><span class="p">,</span><span class="n">_stiffmat</span><span class="p">,</span><span class="n">_RHSvec</span><span class="p">)</span>

            <span class="n">_BC_stiffmatCSR</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">_BC_stiffmat</span><span class="p">)</span>
            <span class="c1">#Solve sistem of equation for disaplcements</span>
            <span class="n">_solu</span> <span class="o">=</span> <span class="n">spsolve</span><span class="p">(</span><span class="n">_BC_stiffmatCSR</span><span class="p">,</span><span class="n">_BC_RHSvec</span><span class="p">)</span>
            <span class="n">_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">_solu</span><span class="p">,(</span><span class="nb">int</span><span class="p">(</span><span class="n">_solu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">_newCoordVec</span> <span class="o">=</span> <span class="n">_newCoordVec</span> <span class="o">+</span> <span class="n">_disps</span>
            <span class="c1">#Calculate bond stretches</span>
            <span class="n">_cur_bond_stretches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_bond_stretches</span><span class="p">(</span><span class="n">_newCoordVec</span><span class="p">)</span>
            <span class="c1"># print(_cur_bond_stretches)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curBondDamage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_bond_damage</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">_cur_bond_stretches</span><span class="p">),</span><span class="n">s1</span><span class="p">,</span><span class="n">sc</span><span class="p">)</span>
            <span class="c1">#Calculate the internal forces based on the calculated stretches</span>
            <span class="n">internal_bondforce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">internal_pointforces</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">_BC_RHSvec</span><span class="p">)</span>
            <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">pd_point_count</span><span class="p">):</span>
                <span class="c1">#Sum the force contributions of all points int the family based on stretches</span>
                <span class="n">internal_bondforce</span> <span class="o">=</span> <span class="n">internal_bondforce</span><span class="o">*</span><span class="mi">0</span>
                <span class="k">for</span> <span class="n">bondid</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">start_idx</span><span class="p">[</span><span class="n">point</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">end_idx</span><span class="p">[</span><span class="n">point</span><span class="p">]):</span>
                    <span class="n">internal_bondforce</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_int_bond_force_from_stretch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">damage_model</span><span class="p">,</span><span class="n">_cur_bond_stretches</span><span class="p">[</span><span class="n">bondid</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">bond_normals</span><span class="p">[</span><span class="n">bondid</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">curBondDamage</span><span class="p">[</span><span class="n">bondid</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">delta</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">delta</span><span class="p">)</span>
                <span class="n">internal_pointforces</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">internal_bondforce</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">internal_pointforces</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">internal_bondforce</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1">#Calculate the residual of the forces (Residual_forces = F_external - F_internal)</span>
            <span class="n">_residual_forces</span> <span class="o">=</span> <span class="p">(</span><span class="n">_BC_RHSvec</span> <span class="o">-</span> <span class="n">internal_pointforces</span><span class="p">)</span>
            <span class="c1"># print(_BC_RHSvec)</span>
            <span class="c1"># print(internal_pointforces)</span>
            <span class="c1"># print(_residual_forces)</span>
            <span class="c1"># Calculate the norm of the residual and check if it is smaller than some defined value for epsilon</span>
            <span class="c1"># _residual_forces_norm = np.linalg.norm(_residual_forces/internal_pointforces)</span>
            <span class="n">dif_vec</span> <span class="o">=</span> <span class="n">_residual_forces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">_residual_forces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="n">internal_pointforces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">internal_pointforces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">_residual_forces_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dif_vec</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">internal_pointforces</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">internal_pointforces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
            <span class="c1">#If residual is small enough return the displacements</span>
            <span class="k">if</span> <span class="n">_residual_forces_norm</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Convergence succesfull in step: </span><span class="si">{</span><span class="nb">iter</span><span class="si">}</span><span class="s2">. Maximum bond stretch = </span><span class="si">{</span><span class="n">_cur_bond_stretches</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">_disps</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Convergence was not achieved! Residual = </span><span class="si">{</span><span class="n">_residual_forces_norm</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_disps</span></div>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_calc_bond_damage</span><span class="p">(</span><span class="n">cur_bondStretches</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">s1</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">sc</span><span class="p">:</span><span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">new_damage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">cur_bondStretches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cur_bondStretches</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span>  <span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">cur_bondStretches</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sc</span><span class="p">:</span>
            <span class="n">new_damage</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc</span><span class="o">/</span><span class="p">(</span><span class="n">sc</span><span class="o">-</span><span class="n">s1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span> <span class="n">s1</span><span class="o">/</span><span class="n">cur_bondStretches</span><span class="p">[</span><span class="n">bond</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cur_bondStretches</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sc</span><span class="p">:</span>
            <span class="n">new_damage</span><span class="p">[</span><span class="n">bond</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">new_damage</span>


<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_generate_stiffness_matrix</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">G11vec</span><span class="p">,</span> <span class="n">G12vec</span><span class="p">,</span><span class="n">G22vec</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">LiveBonds</span><span class="p">,</span> <span class="n">Damage</span><span class="p">,</span> <span class="n">stiffMat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function is only meant to be called inside the &quot;gen_stiffness_matrix&quot; method of the PDFatigueModel class!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">currentBondStatus</span> <span class="o">=</span> <span class="n">LiveBonds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">alive</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">currentBondStatus</span> <span class="o">==</span> <span class="n">alive</span><span class="p">:</span>
                <span class="c1">#Calculate S for the bond between point &quot;j&quot; in family of &quot;pt&quot;</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G11G22</span> <span class="o">=</span> <span class="n">G11</span><span class="o">+</span><span class="n">G22</span>
                <span class="n">S11</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G11</span>
                <span class="n">S12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G12</span>
                <span class="n">S22</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G22</span>

                <span class="c1">#Calculate S for the bond petween point &quot;pt&quot; in family of &quot;j&quot;</span>
                <span class="n">j_pt</span> <span class="o">=</span> <span class="n">find_valueID</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span><span class="n">end_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]],</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">jG11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG11G22</span> <span class="o">=</span> <span class="n">jG11</span><span class="o">+</span><span class="n">jG22</span>
                <span class="n">jS11</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG11</span>
                <span class="n">jS12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG12</span>
                <span class="n">jS22</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG22</span>

                <span class="c1">#Calculate Sbar for bond pt_j (pt is main point j in fam member)</span>
                <span class="n">Sbar11</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S11</span><span class="o">+</span><span class="n">jS11</span><span class="p">)</span>
                <span class="n">Sbar12</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S12</span><span class="o">+</span><span class="n">jS12</span><span class="p">)</span>
                <span class="n">Sbar22</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S22</span><span class="o">+</span><span class="n">jS22</span><span class="p">)</span>

                <span class="c1">#Sum of contibutions of main point in every Xsi</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar11</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar22</span>

                <span class="c1">#Contributions of family members of main point</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar11</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar22</span>

    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">stiffMat</span> <span class="o">*</span> <span class="n">mu</span>
    <span class="k">return</span> <span class="n">stiffMat</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_generate_stiffness_matrix2</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">G11vec</span><span class="p">,</span> <span class="n">G12vec</span><span class="p">,</span><span class="n">G22vec</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">LiveBonds</span><span class="p">,</span> <span class="n">Damage</span><span class="p">,</span> <span class="n">stiffMat</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Generates a stiffness matrix for a given set of coordinates, neighbors, start indices, end indices, G11vec, G12vec, G22vec, mu, LiveBonds, Damage, and an initial stiffness matrix.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - coordVec (ndarray): An array of coordinates.</span>
<span class="sd">    - neighbors (ndarray): An array of indices representing the neighbors of each point.</span>
<span class="sd">    - start_idx (ndarray): An array of start indices for each point&#39;s neighbors.</span>
<span class="sd">    - end_idx (ndarray): An array of end indices for each point&#39;s neighbors.</span>
<span class="sd">    - G11vec (ndarray): An array of G11 values for each point.</span>
<span class="sd">    - G12vec (ndarray): An array of G12 values for each point.</span>
<span class="sd">    - G22vec (ndarray): An array of G22 values for each point.</span>
<span class="sd">    - mu (ndarray): An array of mu values for each point.</span>
<span class="sd">    - LiveBonds (ndarray): An array of boolean values indicating the status of each bond.</span>
<span class="sd">    - Damage (ndarray): An array of damage values for each bond.</span>
<span class="sd">    - stiffMat (ndarray): An initial stiffness matrix.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - stiffMat (ndarray): The updated stiffness matrix after calculating the contributions of each bond and its family members.</span>

<span class="sd">    Comments:</span>
<span class="sd">    Function is only meant to be called inside the &quot;gen_stiffness_matrix&quot; method of the PDFatigueModel class!</span>
<span class="sd">    </span>
<span class="sd">    This function assumes the volumes of all the points in the model are the same.</span>
<span class="sd">    Explanation:</span>
<span class="sd">    The force density acting on a point is calculated as: rho * a [N/m^^3] = Suma{i=1}{N} (fi[N/m^^6] * Vi[m^^3]) = L</span>
<span class="sd">    If all point volumes are the same, then we can rewrite this equation as: rho * a = (Suma{i=1}{N} (fi)) * V = L ; V = Vi for all i.</span>
<span class="sd">    This way we do not need to multiply the force density vectors with Vi for each bonds stiffness contribution, since the equilibrium can be fully obtained using only (Suma{i=1}{N} (fi)) (less computation).</span>
<span class="sd">    BUT!!! -&gt; This also means that the output of K*u != L !!!. To get L we need to multiply the result of K*u with Vi (or V since all Vi = V).</span>
<span class="sd">    To get the force in newtons we need to multiply this L with Vi again.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">currentBondStatus</span> <span class="o">=</span> <span class="n">LiveBonds</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">alive</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">currentBondStatus</span> <span class="o">==</span> <span class="n">alive</span><span class="p">:</span>
                <span class="c1">#Calculate S for the bond between point &quot;j&quot; in family of &quot;pt&quot;</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G11G22</span> <span class="o">=</span> <span class="n">G11</span><span class="o">+</span><span class="n">G22</span>
                <span class="n">S11</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G11</span>
                <span class="n">S12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G12</span>
                <span class="n">S22</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G22</span>

                <span class="c1">#Calculate S for the bond petween point &quot;pt&quot; in family of &quot;j&quot;</span>
                <span class="n">j_pt</span> <span class="o">=</span> <span class="n">find_valueID</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span><span class="n">end_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]],</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">jG11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG11G22</span> <span class="o">=</span> <span class="n">jG11</span><span class="o">+</span><span class="n">jG22</span>
                <span class="n">jS11</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG11</span>
                <span class="n">jS12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG12</span>
                <span class="n">jS22</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG22</span>

                <span class="c1">#Calculate Sbar for bond pt_j (pt is main point j in fam member)</span>
                <span class="n">Sbar11</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S11</span><span class="o">+</span><span class="n">jS11</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Sbar12</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S12</span><span class="o">+</span><span class="n">jS12</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Sbar22</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Damage</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S22</span><span class="o">+</span><span class="n">jS22</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1">#Sum of contibutions of main point in every Xsi</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar11</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sbar22</span>

                <span class="c1">#Contributions of family members of main point</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar11</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">stiffMat</span><span class="p">[</span><span class="n">pt</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar22</span>

    <span class="n">stiffMat</span> <span class="o">=</span> <span class="n">stiffMat</span>
    <span class="k">return</span> <span class="n">stiffMat</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_generate_bond_stiffnesses</span><span class="p">(</span><span class="n">coordVec</span><span class="p">,</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">,</span> <span class="n">G11vec</span><span class="p">,</span> <span class="n">G12vec</span><span class="p">,</span><span class="n">G22vec</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function is only meant to be called inside the &quot;gen_stiffness_matrix&quot; method of the PDFatigueModel class!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bond_stiff_matrix_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coordVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
                <span class="c1">#Calculate S for the bond between point &quot;j&quot; in family of &quot;pt&quot;</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">G11G22</span> <span class="o">=</span> <span class="n">G11</span><span class="o">+</span><span class="n">G22</span>
                <span class="n">S11</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G11</span>
                <span class="n">S12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">G12</span>
                <span class="n">S22</span> <span class="o">=</span> <span class="n">G11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">G22</span>

                <span class="c1">#Calculate S for the bond petween point &quot;pt&quot; in family of &quot;j&quot;</span>
                <span class="n">j_pt</span> <span class="o">=</span> <span class="n">find_valueID</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]:</span><span class="n">end_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]],</span><span class="n">pt</span><span class="p">)</span> <span class="o">+</span> <span class="n">start_idx</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">jG11</span> <span class="o">=</span> <span class="n">G11vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG12</span> <span class="o">=</span> <span class="n">G12vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG22</span> <span class="o">=</span>  <span class="n">G22vec</span><span class="p">[</span><span class="n">j_pt</span><span class="p">]</span>
                <span class="n">jG11G22</span> <span class="o">=</span> <span class="n">jG11</span><span class="o">+</span><span class="n">jG22</span>
                <span class="n">jS11</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG11</span>
                <span class="n">jS12</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG12</span>
                <span class="n">jS22</span> <span class="o">=</span> <span class="n">jG11G22</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">jG22</span>

                <span class="c1">#Calculate Sbar for bond pt_j (pt is main point j in fam member)</span>
                <span class="n">Sbar11</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S11</span><span class="o">+</span><span class="n">jS11</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Sbar12</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S12</span><span class="o">+</span><span class="n">jS12</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">Sbar22</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">S22</span><span class="o">+</span><span class="n">jS22</span><span class="p">)</span> <span class="o">*</span> <span class="n">mu</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>


                <span class="n">bond_stiff_matrix_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar11</span>
                <span class="n">bond_stiff_matrix_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">bond_stiff_matrix_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar12</span>
                <span class="n">bond_stiff_matrix_array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sbar22</span>

    <span class="k">return</span> <span class="n">bond_stiff_matrix_array</span>

<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">_generate_bond_displacement_vecs</span><span class="p">(</span><span class="n">dispVec</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">):</span>

    <span class="n">del_disps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">neighbors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dispVec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">del_disps</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dispVec</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">dispVec</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">del_disps</span>

<div class="viewcode-block" id="generate_force_dens_vecs">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.generate_force_dens_vecs">[docs]</a>
<span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">generate_force_dens_vecs</span><span class="p">(</span><span class="n">bond_stiffness_mat</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">bond_displacement_vecs</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="n">force_dens_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span> <span class="o">=</span> <span class="n">bond_displacement_vecs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bond</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">bond_displacement_vecs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="n">force_dens_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_stiffness_mat</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bond_displacement_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bond_stiffness_mat</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">bond_displacement_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">force_dens_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bond_stiffness_mat</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">bond_displacement_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">bond_stiffness_mat</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">bond_displacement_vecs</span><span class="p">[</span><span class="n">bond</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">force_dens_vecs</span></div>


<div class="viewcode-block" id="family_integration">
<a class="viewcode-back" href="../../libs.html#libs.pddopyW2.family_integration">[docs]</a>
<span class="k">def</span> <span class="nf">family_integration</span><span class="p">(</span><span class="n">neighbors</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">start_idx</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">end_idx</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">bond_values</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">point_volumes</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
    <span class="n">pt_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">point_volumes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">point_volumes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">cur_sum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">],</span><span class="n">end_idx</span><span class="p">[</span><span class="n">pt</span><span class="p">]):</span>
            <span class="n">cur_sum</span> <span class="o">=</span> <span class="n">cur_sum</span> <span class="o">+</span> <span class="n">bond_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">point_volumes</span><span class="p">[</span><span class="n">neighbors</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="n">pt_sum</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_sum</span>
    <span class="k">return</span> <span class="n">pt_sum</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Filip Jerenec.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>